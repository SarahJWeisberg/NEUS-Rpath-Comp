---
title: "Comparisons across NEUS Rpath models"
author: "Sarah J. Weisberg"
date: "2024-03-25"
output: 
  html_document
---

#0 Prep

```{r}
#data organizing and wrangling
library(here)
library(dplyr)
library(tidyr)
library(forcats)
library(data.table)

#plotting
library(RColorBrewer)
library(ggspatial)
library(gridExtra)
library(ggplot2)
library(ggbeeswarm)
library(showtext)
library(igraph)
library(ggnetwork)
library(viridis)
library(patchwork)
library(ggthemes)
library(ggpubr)
library(ggpp)

#spatial tools
remotes::install_github('NEFSC/NEFSC-Spatial')
library(NEFSCspatial)
library(sf)
library(rnaturalearth)
library(rmapshaper)
library(marmap)

#Rpath, enaR
library(devtools)
install.packages("gdata", repos = "https://packagemanager.posit.co/cran/2023-05-06") #need to install an older version of gdata for enaR to install properly
install_github('SEELab/enaR', force = T)
library(gdata)
library(enaR)
library(sna)
remotes::install_github('NOAA-EDAB/Rpath',force = T)
library(Rpath)

#stats tools
library(stats)
library(rstatix)

#set overall theme
theme_Publication <- function(base_size=10, base_family="Arial") {
  
  (theme_foundation(base_size=base_size, base_family=base_family)
   + theme(plot.title = element_text(hjust = 0.5),
           text = element_text(),
           panel.background = element_rect(colour = NA),
           plot.background = element_rect(colour = NA),
           panel.border = element_rect(colour = NA),
           axis.title = element_text(size = rel(1)),
           axis.title.y = element_text(angle=90,vjust =2),
           axis.text = element_text(), 
           axis.line = element_line(colour="black"),
           axis.ticks = element_line(),
           panel.grid.major = element_line(colour="#f0f0f0"),
           panel.grid.minor = element_blank(),
           legend.key = element_rect(colour = NA),
           legend.position = "right",
           legend.spacing  = unit(0, "cm"),
           legend.title = element_text(face="italic"),
           strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0")
   ))
  
}


```

Load in the balanced models from Github

```{r}
#GB
url<-"https://github.com/NOAA-EDAB/GBRpath/blob/max_clam_edits/data/alternate.GB.params.bal.rda?raw=true"
download.file(url,destfile = "GB.params.Rdata")
load("GB.params.Rdata")

url<-"https://github.com/NOAA-EDAB/GBRpath/blob/max_clam_edits/data/alternate.GB.bal.rda?raw=true"
download.file(url,destfile = "GB.bal.Rdata")
load("GB.bal.Rdata")
rm(url)
#rename
GB.bal<-alternate.GB.bal
GB.params.bal<-alternate.GB.params.bal
rm(alternate.GB.bal,alternate.GB.params.bal)

#GOM
load(url("https://github.com/SarahJWeisberg/GOM-Rpath/blob/main/outputs/GOM_Rpath.RData?raw=true"))
load(url("https://github.com/SarahJWeisberg/GOM-Rpath/blob/main/outputs/GOM_params_Rpath.RData?raw=true"))

#MAB
load(url("https://github.com/Nyelab/MAB-Rpath/blob//max_clam_edits/outputs/MAB_params_Rpath_no_disc.RData?raw=true"))
load(url("https://github.com/Nyelab/MAB-Rpath/blob//max_clam_edits/outputs/MAB_Rpath_no_disc.RData?raw=true"))
```

#1 Comparing the balanced models 
##1.1 Groups & Fleets
```{r}
group<-c(GOM$Group,GB.bal$Group,MAB.rpath$Group)
type <- c(GOM$type,GB.bal$type,MAB.rpath$type)
model<-c(rep("GOM",GOM$NUM_GROUPS),rep("GB",GB.bal$NUM_GROUPS),rep("MAB",MAB.rpath$NUM_GROUPS))
all_groups<-as.data.frame(cbind(group,model,type)) 
rownames(all_groups)<-c()

groups_tally<-data.frame(unique(all_groups$group))
colnames(groups_tally)<-"group"
groups_tally <- groups_tally %>% 
  mutate(GOM = ifelse(group %in% GOM$Group,"X",NA), GB = ifelse(group %in% GB.bal$Group,"X",NA),
         MAB = ifelse(group %in% MAB.rpath$Group,"X",NA))

#fleets
all_fleets <- all_groups %>% 
  filter(type==3) %>% 
  dplyr::select(-type)

#rename GB fleets to match GOM, MAB
#will make changes in model creation code
all_fleets <- all_fleets %>%
  mutate(group = ifelse(group == "ClamDredge","Clam Dredge",
                        ifelse(group == "FixedGear","Fixed Gear",
                               ifelse(group == "HMSFleet","HMS Fleet",
                                      ifelse(group == "LargeMesh", "LG Mesh",
                                             ifelse(group == "OtherDredge","Other Dredge",
                                                    ifelse(group == "ScallopDredge","Scallop Dredge",
                                                          ifelse(group == "SmallMesh","SM Mesh",group))))))))
#tally
fleets_tally<-data.frame(unique(all_fleets$group))
colnames(fleets_tally)<-"group"
fleets_tally<- fleets_tally %>% 
  mutate(GOM = ifelse(group %in% all_fleets$group[which(all_fleets$model=="GOM")],"X","-"), 
         GB = ifelse(group %in% all_fleets$group[which(all_fleets$model=="GB")],"X","-"),
         MAB = ifelse(group %in% all_fleets$group[which(all_fleets$model=="MAB")],"X","-"))
  
#add fleet definition info
fleets_tally <- fleets_tally %>% 
  mutate(definition = ifelse(group == "Clam Dredge","NEGEAR2 == 40",
                             ifelse(group == "Fixed Gear","NEGEAR2 %in% c(1, 2, 8, 10, 50, 52, 14, 26)",
                                    ifelse(group == "HMS Fleet", "NEGEAR2 %in% c(3, 4, 6, 11)",
                                           ifelse(group == "LG Mesh","NEGEAR2 %in% c(5, 16, 32, 35, 36)",
                                                   ifelse(group == "Other Dredge","NEGEAR2 %in% c(22, 25, 38, 41)",
                                                          ifelse(group == "Scallop Dredge","NEGEAR2 == 13",
                                                                 ifelse(group=="SM Mesh","NEGEAR2 == 5 & MESHCAT == 'SM'",
                                                                        ifelse(group == "Pelagic", "NEGEAR2 %in% c(12, 17, 37)",
                                                                               ifelse(group == "Trap","NEGEAR2 %in% c(18, 15, 19, 20, 21, 23, 30, 33, 53)",
                                                                                      ifelse(group == "Other","Other NEGEAR2 codes",
                                                                                             ifelse(group == "Recreational","MRIP data",
                                                                                                    ifelse(group == "PurseSeine","Menhaden catch estimate",NA)))))))))))))

#write.csv(fleets_tally,"RPath_fleet_definitions.csv")

#comparing groups 
all_groups<-all_groups %>%
  mutate(PB = c(GOM$PB,GB.bal$PB,MAB.rpath$PB), 
         QB = c(GOM$QB,GB.bal$QB,MAB.rpath$QB),
         Biomass = c(GOM$Biomass,GB.bal$Biomass,MAB.rpath$Biomass),
         EE = c(GOM$EE,GB.bal$EE,MAB.rpath$EE),
         TL = c(GOM$TL,GB.bal$TL,MAB.rpath$TL)) %>% 
  filter(!PB == 0) %>% #get rid of fleets
  mutate(PB = round(PB,2), QB = round(QB,2),Biomass=round(Biomass,2),EE=round(EE,2)) 

ggplot(all_groups,aes(x=model,y=PB,color=model)) +
  geom_bar(stat="identity")+
  geom_text(aes(label=PB),vjust=1.6,size=3)+
  facet_wrap(~group,scales = "free")+
  theme(legend.position = "none")

all_groups %>% filter(!group %in% c("Phytoplankton","Detritus","Discards"))%>%  
ggplot(aes(x=model,y=QB,color=model)) +
  geom_bar(stat="identity")+
  geom_text(aes(label=QB),vjust=1.6,size=3)+
  facet_wrap(~group,scales = "free")+
  theme(legend.position = "none")

all_groups %>%
  filter(!group %in% c("Discards"))%>% 
  ggplot(aes(x=model,y=Biomass,color=model)) +
  geom_bar(stat="identity")+
  geom_text(aes(label=Biomass),vjust=1.6,size=3)+
  facet_wrap(~group,scales = "free")+
  theme(legend.position = "none")
```
##1.2 Cumulative biomass vs. TL, cumulative production
```{r}
all_groups <- all_groups %>% 
  filter(!group %in% c("Detritus","Discards")) %>%
  group_by(model) %>% 
  arrange(TL,.by_group=T) %>% 
  mutate(cum_B = cumsum(Biomass))
  

ggplot(data=all_groups,aes(x=TL,y=cum_B,color=model))+
  geom_line()+
  labs(y="Cumulative Biomass")
  
all_groups <- all_groups %>%
  arrange(cum_B,.by_group = T) %>%
  mutate(prod = PB*Biomass) %>%
  mutate(cum_P = cumsum(prod))

ggplot(data=all_groups,aes(x=cum_B,y=cum_P,color=model))+
  geom_line()+
  labs(x="Cumulative Biomass",y="Cumulative Production")

```


#2 Ecological Network Analysis (ENA)

##2.1 Convert starting models to networks

```{r}
#MAB
#Set up model with group names and types
groups<-as.vector(MAB.rpath$Group)

#Count number of each group type
nliving <- nrow(MAB.rpath.params$model[Type <  2, ])
ndead   <- nrow(MAB.rpath.params$model[Type == 2, ])

#find index of pp
pp <- which(groups == "Phytoplankton")

#pull diet
diet<-MAB.rpath$DC
#Get consumption values by DC*QB*Biomass
QQ<-matrix(nrow = (nliving + ndead + 1),ncol=nliving)
for (j in 1:nliving){
  QQ[,j]<-diet[,j]*MAB.rpath$QB[j]*MAB.rpath$Biomass[j]
}
#Ignore Imports
QQ<-QQ[1:(nliving+ndead),]
colnames(QQ)<-groups[1:nliving]
rownames(QQ)<-groups[1:(nliving+ndead)]
#Calculate flow to detritus
M0<-MAB.rpath$PB*(1-MAB.rpath$EE)
Detritus<-(M0*MAB.rpath$Biomass+MAB.rpath$QB*MAB.rpath$Biomass*MAB.rpath$Unassim)*MAB.rpath$DetFate[,1] + 
  rowSums(MAB.rpath$Discards)
Detritus<-Detritus[1:(nliving+ndead)]
#Flow to detritus from detritus = 0
Detritus[(nliving+1)]<-0
#Bind diet matrix (QQ) with flow to detritus, discards
QQ<-cbind(QQ,Detritus)
#Calculate exports
#First sum catch
Catch<-rowSums(MAB.rpath$Landings)
#Add positive biomass accumulation terms
Export<-Catch+(ifelse(MAB.rpath$BA>0,MAB.rpath$BA*MAB.rpath$Biomass,0))
Export<-Export[1:(nliving+ndead)]
for (i in 1:ndead){
  Export[nliving+i]<-M0[nliving+i]*MAB.rpath$Biomass[nliving+i]
}
#Calculate respiration
#Assume detritus, discards have 0 respiration
Resp<-((1-MAB.rpath$Unassim)*MAB.rpath$QB-MAB.rpath$PB)*MAB.rpath$Biomass
Resp<-ifelse(Resp>0,Resp,0)
Resp<-Resp[1:(nliving+ndead)]
Resp[(nliving+1):(nliving+ndead)]<-0
#Deal with Primary Production
#First, estimate GROSS production = Imports
#P/B in Ecopath model gives NET production
#Ratio of gross:net is going to be fixed based on EMAX
gross_net<-(4251.874+1062.968)/4251.874
gross<-gross_net*MAB.rpath$PB[pp]*MAB.rpath$Biomass[pp]
Resp[pp]<-gross-(MAB.rpath$PB[pp]*MAB.rpath$Biomass[pp])
#Calculate imports
#Negative biomass accumulation terms
#Gross primary production
Import<-abs(ifelse(MAB.rpath$BA<0,MAB.rpath$BA*MAB.rpath$Biomass,0))
Import[pp]<-gross
Import<-Import[1:(nliving+ndead)]
#Trim biomass
Biomass<-MAB.rpath$Biomass[1:(nliving+ndead)]
#Pack the model directly and store
orig_network_MAB<-enaR::pack(flow = QQ,
                         input = Import,
                         export = Export,
                         living = c(rep(TRUE,nliving),rep(FALSE,ndead)),
                         respiration = Resp,
                         storage = Biomass)

#GB
#Set up model with group names and types
groups<-as.vector(GB.bal$Group)

#Count number of each group type
nliving <- nrow(GB.params.bal$model[Type <  2, ])
ndead   <- nrow(GB.params.bal$model[Type == 2, ])

#find index of pp
pp <- which(groups == "Phytoplankton")

#pull diet
diet<-GB.bal$DC
#Get consumption values by DC*QB*Biomass
QQ<-matrix(nrow = (nliving + ndead + 1),ncol=nliving)
for (j in 1:nliving){
  QQ[,j]<-diet[,j]*GB.bal$QB[j]*GB.bal$Biomass[j]
}
#Ignore Imports
QQ<-QQ[1:(nliving+ndead),]
colnames(QQ)<-groups[1:nliving]
rownames(QQ)<-groups[1:(nliving+ndead)]
#Calculate flow to detritus
M0<-GB.bal$PB*(1-GB.bal$EE)
Detritus<-(M0*GB.bal$Biomass+GB.bal$QB*GB.bal$Biomass*GB.bal$Unassim)*GB.bal$DetFate[,1]
Detritus<-Detritus[1:(nliving+ndead)]
#Flow to detritus from detritus = 0
Detritus[(nliving+1)]<-0
#Bind diet matrix (QQ) with flow to detritus, discards
QQ<-cbind(QQ,Detritus)
#Calculate exports
#First sum catch
Catch<-rowSums(GB.bal$Landings)
#Add positive biomass accumulation terms
Export<-Catch+(ifelse(GB.bal$BA>0,GB.bal$BA*GB.bal$Biomass,0))
Export<-Export[1:(nliving+ndead)]
for (i in 1:ndead){
  Export[nliving+i]<-M0[nliving+i]*GB.bal$Biomass[nliving+i]
}
#Calculate respiration
#Assume detritus, discards have 0 respiration
Resp<-((1-GB.bal$Unassim)*GB.bal$QB-GB.bal$PB)*GB.bal$Biomass
Resp<-ifelse(Resp>0,Resp,0)
Resp<-Resp[1:(nliving+ndead)]
Resp[(nliving+1):(nliving+ndead)]<-0
#Deal with Primary Production
#First, estimate GROSS production = Imports
#P/B in Ecopath model gives NET production
#Ratio of gross:net is going to be fixed based on EMAX
gross_net<-(3284.948+821.2371)/3284.948
gross<-gross_net*GB.bal$PB[pp]*GB.bal$Biomass[pp]
Resp[pp]<-gross-(GB.bal$PB[pp]*GB.bal$Biomass[pp])
#Calculate imports
#Negative biomass accumulation terms
#Gross primary production
Import<-abs(ifelse(GB.bal$BA<0,GB.bal$BA*GB.bal$Biomass,0))
Import[pp]<-gross
Import<-Import[1:(nliving+ndead)]
#Trim biomass
Biomass<-GB.bal$Biomass[1:(nliving+ndead)]
#Pack the model directly and store
orig_network_GB<-enaR::pack(flow = QQ,
                         input = Import,
                         export = Export,
                         living = c(rep(TRUE,nliving),rep(FALSE,1)),
                         respiration = Resp,
                         storage = Biomass)
#GOM
#Set up model with group names and types
groups<-as.vector(GOM$Group)

#Count number of each group type
nliving <- nrow(GOM.params$model[Type <  2, ])
ndead   <- nrow(GOM.params$model[Type == 2, ])

#Find index of pp groups
pp<- which(groups == "Phytoplankton")

#Pull diet matrix
diet<-GOM$DC
#Get consumption values by DC*QB*Biomass
QQ<-matrix(nrow = (nliving + ndead + 1),ncol=nliving)
for (j in 1:nliving){
  QQ[,j]<-diet[,j]*GOM$QB[j]*GOM$Biomass[j]
}
#Ignore Imports
QQ<-QQ[1:(nliving+ndead),]
colnames(QQ)<-groups[1:nliving]
rownames(QQ)<-groups[1:(nliving+ndead)]
#Calculate flow to detritus
M0<-GOM$PB*(1-GOM$EE)
Detritus<-(M0*GOM$Biomass+GOM$QB*GOM$Biomass*GOM$Unassim)*GOM$DetFate[,1]
#Detritus<-GOM$QB*GOM$Biomass*GOM$Unassim
Detritus<-Detritus[1:(nliving+ndead)]
#Note that I am ignoring discards here
#Flow to detritus from detritus = 0
Detritus[(nliving+1)]<-0
#Bind diet matrix (QQ) with flow to detritus, discards
QQ<-cbind(QQ,Detritus)
#Calculate exports
#First sum catch
Catch<-rowSums(GOM$Landings)
#Add positive biomass accumulation terms
Export<-Catch+(ifelse(GOM$BA>0,GOM$BA,0))
Export<-Export[1:(nliving+ndead)]
for (i in 1:ndead){
  Export[nliving+i]<-GOM$PB[(nliving+i)]*GOM$Biomass[(nliving+i)]
}
#Calculate respiration
#Assume detritus, discards have 0 respiration
Resp<-((1-GOM$Unassim)*GOM$QB-GOM$PB)*GOM$Biomass
Resp<-ifelse(Resp>0,Resp,0)
Resp<-Resp[1:(nliving+ndead)]
Resp[(nliving+1):(nliving+ndead)]<-0
#Deal with Primary Production
#First, estimate GROSS production = Imports
#P/B in Ecopath model gives NET production
#Ratio of gross:net is going to be fixed based on EMAX
gross_net<-4101.9/3281.5
gross<-gross_net*GOM$PB[1]*GOM$Biomass[1]
Resp[1]<-gross-(GOM$PB[1]*GOM$Biomass[1])
#Calculate imports
#Negative biomass accumulation terms
#Gross primary production
Import<-abs(ifelse(GOM$BA<0,GOM$BA,0))
Import[1]<-gross
Import<-Import[1:(nliving+ndead)]
#Trim biomass
Biomass<-GOM$Biomass[1:(nliving+ndead)]
#Pack the model directly and store
orig_network_GOM<-enaR::pack(flow = QQ,
                         input = Import,
                         export = Export,
                         living = c(rep(TRUE,nliving),rep(FALSE,ndead)),
                         respiration = Resp,
                         storage = Biomass)
```

##2.2 ENA on starting models

```{r}
library(enaR)
orig_networks<-c()
orig_networks$GOM<-orig_network_GOM
info_orig_GOM<-enaAscendency(orig_network_GOM)
info_orig_GOM <- as.data.frame(info_orig_GOM)
orig_networks$GB<-orig_network_GB
info_orig_GB<-enaAscendency(orig_network_GB)
info_orig_GB <- as.data.frame(info_orig_GB)
orig_networks$MAB<-orig_network_MAB
info_orig_MAB<-enaAscendency(orig_network_MAB)
info_orig_MAB <- as.data.frame(info_orig_MAB)
orig_info<-lapply(orig_networks, enaAscendency)
```

#3 Analyze and compare ecosense outputs Load ecosense outputs - initial and constrained

```{r}
#load ecosense outputs
#need to adjust these file names to be more concise
#MAB
#with thermodynamic bounding
load(url("https://github.com/Nyelab/MAB-Rpath/blob/max_clam_edits/outputs/MAB_sense_Rpath_50k_2024.RData?raw=true"))
#without thermodynamic bounding (initial condition)
load(url("https://github.com/Nyelab/MAB-Rpath/blob/max_clam_edits/outputs/MAB_sense_unbound.RData?raw=true"))

#GB
#with thermodynamic bounding
load(url("https://github.com/NOAA-EDAB/GBRpath/blob/max_clam_edits/data/GB_sense_bound.RData?raw=true"))
#without thermodynamic bounding (initial condition)
load(url("https://github.com/NOAA-EDAB/GBRpath/blob/max_clam_edits/data/GB_sense_unbound.RData?raw=true"))

#GOM
#with thermodynamic bounding
load(url("https://github.com/SarahJWeisberg/GOM-Rpath/blob/main/outputs/GOM_sense_50k_resp_constrain.RData?raw=true"))
#without thermodynamic bounding (initial condition)
load(url("https://github.com/SarahJWeisberg/GOM-Rpath/blob/main/outputs/GOM_sense_unbound.RData?raw=true"))
```

#4 ENA on Ecosense outputs 
##4.1 Network conversion of MAB ecosense outputs

```{r}
library(enaR)
#Copy initial Rpath parameters
#Alternative scenarios will be the same except for Biomass, PB, QB, Diet, M0
alt <- copy(MAB.rpath.params)
alt.diet <- copy(MAB.rpath.params$diet)

#Set up model with group names and types
groups <- as.vector(MAB.rpath$Group)
#Count number of each group type
ngroups <- nrow(alt$model)
nliving <- nrow(alt$model[Type <  2, ])
ndead   <- nrow(alt$model[Type == 2, ])
ngear   <- nrow(alt$model[Type == 3, ])
#find index of pp
pp <- which(groups == "Phytoplankton")
#bind constrained and initial outputs
senses<-c(MAB_sense,MAB_sense_unbound)

#calculate ena metrics for all ecosense outputs
alt_networks<-as.list(rep(NA,length(senses)))

for (i in 1:length(senses)) {
  #Copy initial Rpath parameters
  Rpath.alt<-copy(MAB.rpath.params)
  #Copy scenario
  MAB.alt<-senses[[i]]
  #Assign biomass
  #Ignore Outside
  Biomass<-MAB.alt$B_BaseRef[2:(nliving+ndead+1)]
  #Assign PB
  PB<-MAB.alt$PBopt[2:(nliving+ndead+1)]
  #Assign QB
  QB<-MAB.alt$FtimeQBOpt[2:(nliving+ndead+1)]
  QB[pp]<-0
  #Assign M0
  M0<-MAB.alt$MzeroMort[2:(nliving+ndead+1)]
  #Assign diet
  #Remove first two entries which represent 'outside' flow to 'outside' and 'PP'
  PreyFrom<-MAB.alt$PreyFrom[-c(1,2)]
  PreyTo<-MAB.alt$PreyTo[-c(1,2)]
  predpreyQ<-MAB.alt$QQ[-c(1,2)]
  #Fill consumption matrix
  QQ<-matrix(nrow = (nliving + ndead + 1),ncol=nliving)
  for (j in 1:length(PreyFrom)){
    prey<-PreyFrom[j]
    pred<-PreyTo[j]
    QQ[prey,pred]<-predpreyQ[j]
  }
  #convert NAs to 0s
  QQ[which(is.na(QQ)==T)]<-0
  #Ignore Imports
  QQ<-QQ[1:(nliving+ndead),]
  colnames(QQ)<-groups[1:nliving]
  rownames(QQ)<-groups[1:(nliving+ndead)]
  #Calculate flows to detritus
  Unassim<-MAB.alt$UnassimRespFrac[2:(nliving+ndead+1)]
  DetFate<-MAB.alt$DetFrac[2:(nliving+ndead+1)]
  Detritus<-(M0*Biomass+QB*Biomass*Unassim)*DetFate
  #Detritus<-(model$QB*model$Biomass*model$Unassim)*model$DetFate[,1]
  #Detritus<-Detritus[1:(nliving+ndead)]
  #Deal with flow to detritus from discards
  #Should be equal to all flow to discards minus consumption by SeaBirds(45)
  #DetInDisc<-sum(Discards)
  #Detritus[58]<-DetInDisc-QQ[58,45]
  #Flow to detritus from detritus = 0
  Detritus[(nliving+ndead)]<-0
  #Bind diet matrix (QQ) with flow to detritus, discards
  QQ<-cbind(QQ,Detritus)
  #Calculate exports
  #First sum catch
  Catch<-rowSums(MAB.rpath$Landings)[1:(nliving+ndead)]
  #Add positive biomass accumulation terms
  BA<-MAB.rpath$BA[1:(nliving+ndead)]
  Export<-Catch+(ifelse(BA>0,BA*Biomass,0))
  for (k in 1:ndead){
    Export[nliving+k]<-M0[nliving+k]*Biomass[nliving+k]
  }
  Export<-Export[1:(nliving+ndead)]
  #Calculate respiration
  #Assume detritus, discards have 0 respiration
  Resp<-((1-Unassim)*QB-PB)*Biomass
  Resp<-ifelse(Resp>0,Resp,0)
  Resp<-Resp[1:(nliving+ndead)]
  Resp[(nliving+1):(nliving+ndead)]<-0
  #Deal with Primary Production
  #First, estimate GROSS production = Imports
  #P/B in Ecopath model gives NET production
  #Ratio of gross:net is going to be fixed based on EMAX
  gross_net<-(4251.874+1062.968)/4251.874
  gross<-gross_net*PB[pp]*Biomass[pp]
  Resp[pp]<-gross-(PB[pp]*Biomass[pp])
  #Calculate imports
  #Negative biomass accumulation terms
  #Gross primary production
  Import<-abs(ifelse(BA<0,BA*Biomass,0))
  #EE_Biomass<-ifelse(model$EE>1,(model$EE-1)*model$Biomass,0)
  #Import<-BA_Biomass+EE_Biomass
  Import[pp]<-gross
  Import<-Import[1:(nliving+ndead)]
  #Pack the model directly and store
  alt_networks[[i]]<-enaR::pack(flow = QQ,
                                input = Import,
                                export = Export,
                                living = c(rep(TRUE,nliving),rep(FALSE,ndead)),
                                respiration = Resp,
                                storage = Biomass)
}

#pull nodal flows out of each alternate model
MAB_flow<-c()
for (i in 1:length(alt_networks)){
  alt_flow<-enaFlow(alt_networks[[i]],balance.override=T)
  flow_group<-cbind(groups[1:(nliving+ndead)],alt_flow$T)
  MAB_flow<-rbind(MAB_flow,flow_group)
}
#turn flows into one dataframe
MAB_flow <- as.data.frame(MAB_flow)
rownames(MAB_flow)<-c()
colnames(MAB_flow)<-c("group","flow")
MAB_flow<- MAB_flow %>% mutate(EPU = "MAB") %>%
  mutate(flow=as.numeric(flow)) %>% 
  mutate(condition = c(rep("constrained",length(MAB_sense)*(nliving+ndead)),rep("initial",length(MAB_sense_unbound)*(nliving+ndead))))

#run ascendancy analysis on each alternate model
MAB_info<-lapply(alt_networks, enaAscendency)

rm(alt_networks)
```
##4.2 Network conversion of GB ecosense outputs

```{r}
#Copy initial Rpath parameters
#Alternative scenarios will be the same except for Biomass, PB, QB, Diet, M0
alt<-copy(GB.params.bal)
alt.diet<-copy(GB.params.bal$diet)
#Set up model with group names and types
groups<-as.vector(GB.bal$Group)
#Count number of each group type
ngroups <- nrow(alt$model)
nliving <- nrow(alt$model[Type <  2, ])
ndead   <- nrow(alt$model[Type == 2, ])
ngear   <- nrow(alt$model[Type == 3, ])
#find index of pp
pp <- which(groups == "Phytoplankton")

#bind constrained and initial outputs
senses<-c(GB_sense_bound_bac,GB_sense_unbound_bac)
#generate network models
alt_networks<-as.list(rep(NA,length(senses)))

#start with thermodynamically bound outputs
for (i in 1:length(senses)) {
  model<-senses[[i]]
  #Assign biomass, ignore Outside
  Biomass<-model$B_BaseRef[2:(nliving+ndead+1)]
  #Assign PB
  PB<-model$PBopt[2:(nliving+ndead+1)]
  #Assign QB
  QB<-model$FtimeQBOpt[2:(nliving+ndead+1)]
  QB[pp]<-0
  #Assign M0
  M0<-model$MzeroMort[2:(nliving+ndead+1)]
  #Assign diet
  #Remove first two entries which represent 'outside' flow to 'outside' and 'PP'
  PreyFrom<-model$PreyFrom[-c(1,2)]
  PreyTo<-model$PreyTo[-c(1,2)]
  predpreyQ<-model$QQ[-c(1,2)]
  #Fill consumption matrix
  QQ<-matrix(nrow = (nliving + ndead + 1),ncol=nliving)
  for (j in 1:length(PreyFrom)){
    prey<-PreyFrom[j]
    pred<-PreyTo[j]
    QQ[prey,pred]<-predpreyQ[j]
  }
  #convert NAs to 0s
  QQ[which(is.na(QQ)==T)]<-0
  #Ignore Imports
  QQ<-QQ[1:(nliving+ndead),]
  colnames(QQ)<-groups[1:nliving]
  rownames(QQ)<-groups[1:(nliving+ndead)]
  #Calculate flows to detritus
  Unassim<-model$UnassimRespFrac[2:(nliving+ndead+1)]
  DetFate<-model$DetFrac[2:(nliving+ndead+1)]
  Detritus<-(M0*Biomass+QB*Biomass*Unassim)*DetFate
  #Flow to detritus from detritus = 0
  Detritus[(nliving+ndead)]<-0
  #Bind diet matrix (QQ) with flow to detritus, discards
  QQ<-cbind(QQ,Detritus)
  #Calculate exports
  #First sum catch
  #Catch doesn't change in Ecosense so am pulling from original model
  Catch<-rowSums(GB.bal$Landings)[1:(nliving+ndead)]
  #Add positive biomass accumulation terms
  BA<-GB.bal$BA[1:(nliving+ndead)]
  Export<-Catch+(ifelse(BA>0,BA*Biomass,0))
  for (k in 1:ndead){
    Export[nliving+k]<-M0[(nliving+k)]*Biomass[(nliving+k)]
  }
  Export<-Export[1:(nliving+ndead)]
  #Calculate respiration
  #Assume detritus, discards have 0 respiration
  Resp<-((1-Unassim)*QB-PB)*Biomass
  Resp<-ifelse(Resp>0,Resp,0)
  Resp<-Resp[1:(nliving+ndead)]
  Resp[(nliving+1):(nliving+ndead)]<-0
  #Deal with Primary Production
  #First, estimate GROSS production = Imports
  #P/B in Ecopath model gives NET production
  #Ratio of gross:net is going to be fixed based on EMAX
  gross_net<-(3284.948+821.2371)/3284.948
  gross<-gross_net*PB[pp]*Biomass[pp]
  Resp[pp]<-gross-(PB[pp]*Biomass[pp])
  Import<-abs(ifelse(BA<0,BA*Biomass,0)) 
  Import[pp]<-gross
  Import<-Import[1:(nliving+ndead)]
  alt_networks[[i]]<-enaR::pack(flow = QQ,
                                input = Import,
                                export = Export,
                                living = c(rep(TRUE,nliving),rep(FALSE,ndead)),
                                respiration = Resp,
                                storage = Biomass)
}

#pull nodal flows out of each alternate model
GB_flow<-c()
for (i in 1:length(alt_networks)){
  alt_flow<-enaFlow(alt_networks[[i]],balance.override=T)
  flow_group<-cbind(groups[1:(nliving+ndead)],alt_flow$T)
  GB_flow<-rbind(GB_flow,flow_group)
}
#turn flows into one dataframe
GB_flow <- as.data.frame(GB_flow)
rownames(GB_flow)<-c()
colnames(GB_flow)<-c("group","flow")
GB_flow<- GB_flow %>% mutate(EPU = "GB") %>% mutate(flow=as.numeric(flow)) %>% 
  mutate(condition = c(rep("constrained",length(GB_sense_bound_bac)*(nliving+ndead)),rep("initial",length(GB_sense_unbound_bac)*(nliving+ndead))))

#run ascendancy analysis on each alternate model
GB_info<-lapply(alt_networks, enaAscendency)

rm(alt_networks)
```
##4.3 Network conversion of GOM ecosense outputs

```{r}
#Copy initial Rpath parameters
#Alternative scenarios will be the same except for Biomass, PB, QB, Diet, M0
alt<-copy(GOM.params)
alt.diet<-copy(GOM.params$diet)
#Set up model with group names and types
groups<-as.vector(GOM$Group)
#Count number of each group type
ngroups <- nrow(alt$model)
nliving <- nrow(alt$model[Type <  2, ])
ndead   <- nrow(alt$model[Type == 2, ])
ngear   <- nrow(alt$model[Type == 3, ])
#find index of pp
pp <- which(groups == "Phytoplankton")

#bind constrained and initial outputs
senses<-c(GOM_sense,GOM_sense_unbound)
#generate network models
alt_networks<-as.list(rep(NA,length(senses)))

#start with thermodynamically bound outputs
for (i in 1:length(senses)) {
  model<-senses[[i]]
  #Assign biomass, ignore Outside
  Biomass<-model$B_BaseRef[2:(nliving+ndead+1)]
  #Assign PB
  PB<-model$PBopt[2:(nliving+ndead+1)]
  #Assign QB
  QB<-model$FtimeQBOpt[2:(nliving+ndead+1)]
  QB[pp]<-0
  #Assign M0
  M0<-model$MzeroMort[2:(nliving+ndead+1)]
  #Assign diet
  #Remove first two entries which represent 'outside' flow to 'outside' and 'PP'
  PreyFrom<-model$PreyFrom[-c(1,2)]
  PreyTo<-model$PreyTo[-c(1,2)]
  predpreyQ<-model$QQ[-c(1,2)]
  #Fill consumption matrix
  QQ<-matrix(nrow = (nliving + ndead + 1),ncol=nliving)
  for (j in 1:length(PreyFrom)){
    prey<-PreyFrom[j]
    pred<-PreyTo[j]
    QQ[prey,pred]<-predpreyQ[j]
  }
  #convert NAs to 0s
  QQ[which(is.na(QQ)==T)]<-0
  #Ignore Imports
  QQ<-QQ[1:(nliving+ndead),]
  colnames(QQ)<-groups[1:nliving]
  rownames(QQ)<-groups[1:(nliving+ndead)]
  #Calculate flows to detritus
  Unassim<-model$UnassimRespFrac[2:(nliving+ndead+1)]
  DetFate<-model$DetFrac[2:(nliving+ndead+1)]
  Detritus<-(M0*Biomass+QB*Biomass*Unassim)*DetFate
  #Flow to detritus from detritus = 0
  Detritus[(nliving+ndead)]<-0
  #Bind diet matrix (QQ) with flow to detritus, discards
  QQ<-cbind(QQ,Detritus)
  #Calculate exports
  #First sum catch
  #Catch doesn't change in Ecosense so am pulling from original model
  Catch<-rowSums(GOM$Landings)[1:(nliving+ndead)]
  #Add positive biomass accumulation terms
  BA<-GOM$BA[1:(nliving+ndead)]
  Export<-Catch+(ifelse(BA>0,BA*Biomass,0))
  for (k in 1:ndead){
    Export[nliving+k]<-M0[(nliving+k)]*Biomass[(nliving+k)]
  }
  Export<-Export[1:(nliving+ndead)]
  #Calculate respiration
  #Assume detritus, discards have 0 respiration
  Resp<-((1-Unassim)*QB-PB)*Biomass
  Resp<-ifelse(Resp>0,Resp,0)
  Resp<-Resp[1:(nliving+ndead)]
  Resp[(nliving+1):(nliving+ndead)]<-0
  #Deal with Primary Production
  #First, estimate GROSS production = Imports
  #P/B in Ecopath model gives NET production
  #Ratio of gross:net is going to be fixed based on EMAX
  gross_net<-4101.9/3281.5
  gross<-gross_net*PB[pp]*Biomass[pp]
  Resp[pp]<-gross-(PB[pp]*Biomass[pp])
  Import<-abs(ifelse(BA<0,BA*Biomass,0)) 
  Import[pp]<-gross
  Import<-Import[1:(nliving+ndead)]
  alt_networks[[i]]<-enaR::pack(flow = QQ,
                                input = Import,
                                export = Export,
                                living = c(rep(TRUE,nliving),rep(FALSE,ndead)),
                                respiration = Resp,
                                storage = Biomass)
}

#pull nodal flows out of each alternate model
GOM_flow<-c()
for (i in 1:length(alt_networks)){
  alt_flow<-enaFlow(alt_networks[[i]],balance.override=T)
  flow_group<-cbind(groups[1:(nliving+ndead)],alt_flow$T)
  GOM_flow<-rbind(GOM_flow,flow_group)
}
#turn flows into one dataframe
GOM_flow <- as.data.frame(GOM_flow)
rownames(GOM_flow)<-c()
colnames(GOM_flow)<-c("group","flow")
GOM_flow<- GOM_flow %>% mutate(EPU = "GOM") %>% mutate(flow=as.numeric(flow)) %>% 
  mutate(condition = c(rep("constrained",length(GOM_sense)*(nliving+ndead)),rep("initial",length(GOM_sense_unbound)*(nliving+ndead))))

#run ascendancy analysis on each alternate model
GOM_info<-lapply(alt_networks, enaAscendency)

rm(alt_networks)
```

##4.3 Comparing initial/constrained

```{r}
#turn all flows into one dataframe
flow <- rbind(GOM_flow,GB_flow,MAB_flow)

#Get one dataframe with all groups
#MAB
nliving_MAB <- nrow(MAB.rpath.params$model[Type <  2, ])
ndead_MAB   <- nrow(MAB.rpath.params$model[Type == 2, ])
groups_MAB <- as.vector(MAB.rpath$Group)[1:(nliving_MAB+ndead_MAB)]
#GB
nliving_GB <- nrow(GB.params.bal$model[Type <  2, ])
ndead_GB   <- nrow(GB.params.bal$model[Type == 2, ])
groups_GB <- as.vector(GB.bal$Group)[1:(nliving_GB+ndead_GB)]
#GOM
nliving_GOM <- nrow(GOM.params$model[Type <  2, ])
ndead_GOM   <- nrow(GOM.params$model[Type == 2, ])
groups_GOM <- as.vector(GOM$Group)[1:(nliving_GOM+ndead_GOM)]
                          
group <- c(groups_MAB,groups_GB,groups_GOM)
EPU <- c(rep("MAB",nliving_MAB+ndead_MAB),rep("GB",nliving_GB+ndead_GB),rep("GOM",nliving_GOM+ndead_GOM))

groups <- as.data.frame(cbind(group,EPU))
#which flow distributions are not the same?groups_GOM#which flow distributions are not the same?
#test with Kolmogorov–Smirnov test
ks_flow<-c()
for (j in 1:length(unique(flow$EPU))){
  EPU_test<-unique(flow$EPU)[j]
  EPU_flow<-flow %>% filter(EPU==EPU_test)
  EPU_groups<-groups %>% filter(EPU==EPU_test)
  for(i in 1:length(EPU_groups$group)){
    bound<-EPU_flow %>% filter(group == EPU_groups$group[i],condition == "constrained")
    unbound<-EPU_flow %>% filter(group == EPU_groups$group[i], condition == "initial")
    test<-ks.test(bound$flow,unbound$flow)
    ks_flow<-rbind(ks_flow,c(EPU_groups$group[i],test$p.value,EPU_test))
  }
ks_flow<-as.data.frame(ks_flow)
colnames(ks_flow)<-c("group","p","EPU")
ks_flow$p<-as.numeric(ks_flow$p)
}


#how does A/C compare between constrained and initial?
#Pick out relative ascendancy metric
#GOM
ASC_CAP_GOM<-c()
for (i in 1:length(GOM_info)){
  ASC_CAP_GOM[i]<-GOM_info[[i]][[7]]
}
ASC_CAP_GOM<-as.data.frame(cbind(ASC_CAP_GOM,c(rep("constrained",length(GOM_sense)),rep("initial",length(GOM_sense_unbound)))))
ASC_CAP_GOM<- ASC_CAP_GOM %>% 
  mutate(ASC_CAP = as.numeric(ASC_CAP_GOM)) %>% 
  rename(condition = V2) %>% 
  dplyr::select(-ASC_CAP_GOM) %>%
  mutate(EPU = "GOM")

#ks testing, summary statistics
bound<-ASC_CAP_GOM %>% filter(condition == "constrained") 
unbound<-ASC_CAP_GOM %>% filter(condition == "initial") 
ks.test(bound$ASC_CAP,unbound$ASC_CAP)
bound %>% summarise(mean = mean(ASC_CAP), sd = sd(ASC_CAP))
unbound %>% summarise(mean = mean(ASC_CAP), sd = sd(ASC_CAP))
#test for normality
ggqqplot(bound$ASC_CAP)
ggqqplot(unbound$ASC_CAP)
shapiro.test(bound$ASC_CAP)
shapiro.test(unbound$ASC_CAP)
#not normally distributed, so use non-parametric test instead
wilcox_GOM<- ASC_CAP_GOM %>% wilcox_test(ASC_CAP ~ condition) %>% add_significance()

#GB
ASC_CAP_GB<-c()
for (i in 1:length(GB_info)){
  ASC_CAP_GB[i]<-GB_info[[i]][[7]]
}
ASC_CAP_GB<-as.data.frame(cbind(ASC_CAP_GB,c(rep("constrained",length(GB_sense)),rep("initial",length(GB_sense_unbound)))))
ASC_CAP_GB<- ASC_CAP_GB %>% 
  mutate(ASC_CAP = as.numeric(ASC_CAP_GB)) %>% 
  rename(condition = V2) %>% 
  dplyr::select(-ASC_CAP_GB) %>%
  mutate(EPU = "GB")

#summary statistics
bound<-ASC_CAP_GB %>% filter(condition == "constrained") 
unbound<-ASC_CAP_GB %>% filter(condition == "initial") 
ks.test(bound$ASC_CAP,unbound$ASC_CAP)
bound %>% summarise(mean = mean(ASC_CAP), sd = sd(ASC_CAP))
unbound %>% summarise(mean = mean(ASC_CAP), sd = sd(ASC_CAP))
#test for normality
ggqqplot(bound$ASC_CAP)
ggqqplot(unbound$ASC_CAP)
shapiro.test(bound$ASC_CAP)
shapiro.test(unbound$ASC_CAP)
#distributions are not normal, cannot use t-test to compare between means
#use non-parametric test instead
wilcox_GB<- ASC_CAP_GB %>% wilcox_test(ASC_CAP ~ condition)

#MAB
ASC_CAP_MAB<-c()
for (i in 1:length(MAB_info)){
  ASC_CAP_MAB[i]<-MAB_info[[i]][[7]]
}
ASC_CAP_MAB<-as.data.frame(cbind(ASC_CAP_MAB,c(rep("constrained",length(MAB_sense)),rep("initial",length(MAB_sense_unbound)))))
ASC_CAP_MAB<- ASC_CAP_MAB %>% 
  mutate(ASC_CAP = as.numeric(ASC_CAP_MAB)) %>% 
  rename(condition = V2) %>% 
  dplyr::select(-ASC_CAP_MAB) %>%
  mutate(EPU = "MAB")

#test for differences, summary statistics
bound<-ASC_CAP_MAB %>% filter(condition == "constrained")
unbound<-ASC_CAP_MAB %>% filter(condition == "initial") 
ks.test(bound$ASC_CAP,unbound$ASC_CAP)
bound %>% summarise(mean = mean(ASC_CAP), sd = sd(ASC_CAP))
unbound  %>% summarise(mean = mean(ASC_CAP), sd = sd(ASC_CAP))
#test for normality
ggqqplot(bound$ASC_CAP)
ggqqplot(unbound$ASC_CAP)
shapiro.test(bound$ASC_CAP)
shapiro.test(unbound$ASC_CAP)
#distributions are not normal, cannot use t-test to compare between means
#use non-parametric test instead
wilcox_MAB<- ASC_CAP_MAB %>% wilcox_test(ASC_CAP ~ condition)

ASC_CAP<-rbind(ASC_CAP_GOM,ASC_CAP_GB,ASC_CAP_MAB)

#ANOVA to test for differences between EPUs
bound<-ASC_CAP %>% filter(condition == "constrained")
test_bound<-kruskal_test(data=bound,ASC_CAP~EPU)
unbound<-ASC_CAP %>% filter(condition == "initial")
test_unbound<-kruskal_test(data=unbound,ASC_CAP~EPU)
```

#5 Figures 
## 5.1 Figure 1: Map

```{r}
bts<-NEFSCspatial::BTS_Strata

MAB_strata <- c(1010:1080, 1100:1120, 1600:1750, 3010:3450, 3470, 3500, 3510)
GB_strata  <- c(1090, 1130:1210, 1230, 1250, 3460, 3480, 3490, 3520:3550)
GOM_strata <- c(1220, 1240, 1260:1290, 1360:1400, 3560:3830)

bts_area<- bts %>% 
  mutate(EPU = ifelse(STRATA %in% MAB_strata,"MAB",ifelse(STRATA %in% GB_strata,"GB",ifelse(STRATA %in% GOM_strata,"GOM","other"))))

theme_set(theme_bw())

#load in countries for plotting 
world <- ne_countries(scale = "large", returnclass = "sf")

#generate region outline polygons
Region <- bts_area %>% filter(!EPU == "other") %>%
  st_make_valid() %>% st_buffer(0) %>% group_by(EPU) %>% summarize()
Region <- ms_filter_islands(Region, min_area=100000000000000) #get rid of that weird one in the gulf of maine 
#Region <- ms_simplify(Region,keep = 0.003, weighting = 11)

# call in bathymetric data
# convert  bathymetric contours into dataframe
bathy <- getNOAA.bathy(-80, -64.5, 34, 46, resolution=1); bathydf <- as.xyz(bathy) 
#ignore positive depth (land)
bathy_sea <- bathydf; bathy_sea$V3[bathy_sea$V3 > 1] <- 0
#ignore depths greater than 500m
bathy_shelf<-bathy_sea %>% filter(V3 > -500) 

#add EEZ line
#eez_boundaries <- sf::st_read("World_EEZ_v12_20231025", layer="eez_boundaries_v12")
#filter for canadian boundaries
#try a different approach
#eez_canada<- eez_boundaries %>% filter(TERRITORY1 == "Canada" | TERRITORY2 == "Canada" | TERRITORY3 == "Canada")
  

#make table of summary stats for each model
GOM_summary<-cbind(nrow(GOM.params$model[Type <  2, ]),nrow(GOM.params$model[Type == 3, ]))
GB_summary<-cbind(nrow(GB.params.bal$model[Type <  2, ]),nrow(GB.params.bal$model[Type == 3, ]))
MAB_summary<-cbind(nrow(MAB.rpath.params$model[Type <  2, ]),nrow(MAB.rpath.params$model[Type == 3, ]))
summary_stats<-data.frame(rbind(GOM_summary,GB_summary,MAB_summary))
rownames(summary_stats)<-c("GOM","GB","MAB")
colnames(summary_stats)<-c("Living Groups","Fleets")
#tt<-ttheme_default(core=list(bg_params = list(fill=c("#377EB8","#FF7F00","#E41A1C"),alpha=0.7)))

#plot  
NEUS <- ggplot() +
  geom_sf(data = world)+
  geom_raster(data = bathy_shelf, aes(x = V1, y = V2, fill = V3)) +
  scale_fill_gradient(low="#586575", high="#daedf7",
                      breaks = c(-400,-250,-100),labels=c(400,250,100))+
  geom_sf(data = world)+
  geom_sf(data = Region, fill = NA, linewidth = .75)+
  #scale_color_manual(values = c("#FF7F00","#377EB8","#E41A1C"))+
  #geom_sf(data=eez_canada)+
  coord_sf(xlim =c(-78, -65.5), ylim = c(35, 45)) + #zoomed to Hatteras and N
  labs(x = NULL, y = NULL,fill= "Depth (m)") +
  guides(color="none",fill=guide_colorbar(reverse = T))+
  annotate("text",x=-72,y=38.5,label="Mid-Atlantic Bight",size=4)+
  annotate("text", x = -71.75, y = 43, label = "Gulf of Maine", size = 4)+
  annotate("text", x = -66, y = 40.5, label = "Georges Bank", size = 4)+
  annotation_custom(tableGrob(summary_stats),xmin=-69, xmax=-65.5, ymin=36.25, ymax=38)+
  ggspatial::annotation_scale(location = "br",bar_cols = c("grey60", "white")) +
  theme(plot.margin = margin(0, 0, 0, 0, "cm"),
        panel.grid.major = element_blank(),
        #panel.border = element_blank(),
        legend.position = "inside",
        legend.position.inside = c(0.85,0.1),
        legend.title = element_text(face="italic"),
        legend.direction = "horizontal")

NEUS
```
## 5.1.1 Simplified map for talk

```{r}
bts<-NEFSCspatial::BTS_Strata

MAB_strata <- c(1010:1080, 1100:1120, 1600:1750, 3010:3450, 3470, 3500, 3510)
GB_strata  <- c(1090, 1130:1210, 1230, 1250, 3460, 3480, 3490, 3520:3550)
GOM_strata <- c(1220, 1240, 1260:1290, 1360:1400, 3560:3830)

bts_area<- bts %>% 
  mutate(EPU = ifelse(STRATA %in% MAB_strata,"MAB",ifelse(STRATA %in% GB_strata,"GB",ifelse(STRATA %in% GOM_strata,"GOM","other"))))

theme_set(theme_bw())

#load in countries for plotting 
world <- ne_countries(scale = "large", returnclass = "sf")

#generate region outline polygons
Region <- bts_area %>% filter(!EPU == "other") %>%
  st_make_valid() %>% st_buffer(0) %>% group_by(EPU) %>% summarize()
Region <- ms_filter_islands(Region, min_area=100000000000000) #get rid of that weird one in the gulf of maine 
#Region <- ms_simplify(Region,keep = 0.003, weighting = 11)

# call in bathymetric data
# convert  bathymetric contours into dataframe
bathy <- getNOAA.bathy(-80, -64.5, 34, 46, resolution=1); bathydf <- as.xyz(bathy) 
#ignore positive depth (land)
bathy_sea <- bathydf; bathy_sea$V3[bathy_sea$V3 > 1] <- 0
#ignore depths greater than 500m
#bathy_shelf<-bathy_sea %>% filter(V3 > -500) 

usa <- st_as_sf(maps::map("state", fill=TRUE, plot =FALSE))
#plot  
NEUS <- ggplot() +
  geom_sf()+
  geom_raster(data = bathy_sea, aes(x = V1, y = V2, fill = V3)) +
  scale_fill_gradient(low="#586575", high="#daedf7",
                      breaks = c(-5000,-3000,-1000),labels=c("5k","3k","1k"))+
  #geom_sf(data = world)+
  geom_sf(data = usa)+
 #geom_sf(data = Region, fill = NA, linewidth = .75)+
  #scale_color_manual(values = c("#FF7F00","#377EB8","#E41A1C"))+
  #geom_sf(data=eez_canada)+
  coord_sf(xlim =c(-78, -65.5), ylim = c(35, 45)) + #zoomed to Hatteras and N
  labs(x = NULL, y = NULL,fill= "Depth (m)") +
  guides(color="none",fill=guide_colorbar(reverse = T))+
  annotate("text",x=-74,y=39,label="Mid-Atlantic Bight",size=6,angle=50)+
  annotate("text", x = -69, y = 43, label = "Gulf of Maine", size = 6)+
  annotate("text", x = -68.75, y = 40.75, label = "Georges Bank", size = 6,angle=10)+
  #annotation_custom(tableGrob(summary_stats),xmin=-69, xmax=-65.5, ymin=36.25, ymax=38)+
  #ggspatial::annotation_scale(location = "br",bar_cols = c("grey60", "white")) +
  theme(plot.margin = margin(0, 0, 0, 0, "cm"),
        panel.grid.major = element_blank(),
        #panel.border = element_blank(),
        legend.position = "bottom",
        #legend.position.inside = c(0.85,0.1),
        legend.title = element_text(face="italic",size=18),
        legend.direction = "horizontal",
        legend.text = element_text(size=12, color="black"),
        axis.text=element_text(size=12, color="black"))

NEUS

```
##5.2 Figure 2: Network diagrams

```{r}
library(enaR)
#start with MAB
#pull network structure
A<-enaStructure(orig_network_MAB)$A
g<-igraph::graph_from_adjacency_matrix(A)

groups<-MAB.rpath$Group
#Count number of each group type
nliving <- nrow(MAB.rpath.params$model[Type <  2, ])
ndead   <- nrow(MAB.rpath.params$model[Type == 2, ])

#get x and y coordinates
#derived from the plotfw function (https://rfrelat.github.io/BalticFoodWeb.html)
nylevel<-7 #determines number of levels along y-axis
n <- vcount(g) #number of vertices
tl<-MAB.rpath$TL[1:(nliving+ndead)] #pull trophic level calculations from rpath
bks <- c(0.9, seq(1.9, max(tl), length.out = nylevel))
ynod <- cut(tl, breaks = bks, include.lowest = TRUE, 
            labels = 1:(length(bks)-1)) #assign group to a y-level
maxx <- max(table(ynod)) #looks for max # of groups at any y-level
xnod <- rep(0,n)
for (i in 1:nylevel){
  l <- sum(ynod==i)
  
  ltr <- (l/maxx)**(1/2)*maxx
  if (l>1) {
    xnod[ynod==i] <- seq(-ltr,ltr,length.out = l)
  } else {
    xnod[ynod==i] <- 0
  }
}

coo <- cbind(xnod,tl) #these inform x and y coordinates

#manually adjust positions of megabenthos, microzooplankton,loligo, smoothdogfish
coo["Microzooplankton",1]<-6
coo["Megabenthos",1]<-12
coo["SmCopepods",1]<-10
coo["Loligo",1]<-(-2)
coo["SmoothDogfish",1]<-6.5

#pull a few other values for alignment with other models
bac<-coo["Bacteria",1]
macro<-coo["Macrobenthos",1]
lg<-coo["LgCopepods",1]
scallop<-coo["AtlScallop",1]
#use ggnetwork to create a network geometry
#storage and flows from original model
n_MAB<-ggnetwork(orig_network_MAB,layout=coo,weights="flow")
#bind with TL info
TL<-as.data.frame(cbind(MAB.rpath$TL,groups)) %>% rename(vertex.names=groups,TL=V1)
TL<-TL %>% mutate(TL = as.numeric(TL)) %>% mutate(TL = round(TL,2))
n_MAB<-left_join(n_MAB,TL,by="vertex.names")

#GB
#pull network structure
A<-enaStructure(orig_network_GB)$A
g<-igraph::graph_from_adjacency_matrix(A)

groups<-GB.bal$Group
#Count number of each group type
nliving <- nrow(GB.params.bal$model[Type <  2, ])
ndead   <- nrow(GB.params.bal$model[Type == 2, ])

#get x and y coordinates
#derived from the plotfw function (https://rfrelat.github.io/BalticFoodWeb.html)
nylevel<-7 #determines number of levels along y-axis
n <- vcount(g) #number of vertices
tl<-GB.bal$TL[1:(nliving+ndead)] #pull trophic level calculations from rpath
bks <- c(0.9, seq(1.9, max(tl), length.out = nylevel))
ynod <- cut(tl, breaks = bks, include.lowest = TRUE, 
            labels = 1:(length(bks)-1)) #assign group to a y-level
maxx <- max(table(ynod)) #looks for max # of groups at any y-level
xnod <- rep(0,n)
for (i in 1:nylevel){
  l <- sum(ynod==i)
  
  ltr <- (l/maxx)**(1/2)*maxx
  if (l>1) {
    xnod[ynod==i] <- seq(-ltr,ltr,length.out = l)
  } else {
    xnod[ynod==i] <- 0
  }
}

coo <- cbind(xnod,tl) #these inform x and y coordinates
#manual adjustments and alignments
coo["SouthernDemersals",1]<-2.5 
coo["OceanQuahog",1]<-3.5
coo["OtherShrimps",1]<-(-4)
coo["Windowpane",1]<-4.5
coo["Microzooplankton",1]<-6
coo["Megabenthos",1]<-12
coo["SmCopepods",1]<-10
coo["Bacteria",1]<-bac
coo["Macrobenthos",1]<-macro
coo["LgCopepods",1]<-lg


#use ggnetwork to create a network geometry
#storage and flows from original model
n_GB<-ggnetwork(orig_network_GB,layout=coo,weights="flow")
#bind with TL info
TL<-as.data.frame(cbind(GB.bal$TL,groups)) %>% rename(vertex.names=groups,TL=V1)
TL<-TL %>% mutate(TL = as.numeric(TL)) %>% mutate(TL = round(TL,2))
n_GB<-left_join(n_GB,TL,by="vertex.names")

#adjust Detritus storage so it doesn't swamp everything
det_GB<-max(GB.bal$Biomass)
n_GB<-n_GB %>% mutate(storage_adjust = ifelse(storage == det_GB,100,storage))
n_GB <- n_GB %>% mutate(storage_adjust = ifelse(storage < 0.05,0.05,storage_adjust))

#GOM
#pull group list
groups_GOM<-GOM$Group
#Count number of each group type
nliving <- nrow(GOM.params$model[Type <  2, ])
ndead   <- nrow(GOM.params$model[Type == 2, ])

A<-enaStructure(orig_network_GOM)$A
g<-igraph::graph_from_adjacency_matrix(A)

#get x and y coordinates
#derived from the plotfw function (https://rfrelat.github.io/BalticFoodWeb.html)
nylevel<-7 #determines number of levels along y-axis
n <- vcount(g) #number of vertices
tl<-GOM$TL[1:(nliving+ndead)] #pull trophic level calculations from rpath
bks <- c(0.9, seq(1.9, max(tl), length.out = nylevel))
ynod <- cut(tl, breaks = bks, include.lowest = TRUE, 
            labels = 1:(length(bks)-1)) #assign group to a y-level
maxx <- max(table(ynod)) #looks for max # of groups at any y-level
xnod <- rep(0,n)
for (i in 1:nylevel){
  l <- sum(ynod==i)
  
  ltr <- (l/maxx)**(1/2)*maxx
  if (l>1) {
    xnod[ynod==i] <- seq(-ltr,ltr,length.out = l)
  } else {
    xnod[ynod==i] <- 0
  }
}

coo <- cbind(xnod,tl) #these inform x and y coordinates

#move groups manually as needed
coo[2,1]<-(-10)
coo[31,1]<-7
coo[48,1]<-16
coo[3,1]<-0
coo[6,1]<-4
coo["Microzooplankton",1]<-6
coo["Megabenthos",1]<-12
coo["SmCopepods",1]<-10
coo["Bacteria",1]<-bac
coo["Macrobenthos",1]<-macro
coo["LgCopepods",1]<-lg
coo["AtlScallop",1]<-scallop


#use ggnetwork to create a network geometry
#storage and flows from original model
n_GOM<-ggnetwork(orig_network_GOM,layout=coo,weights="flow")
#bind with TL info
TL<-as.data.frame(cbind(GOM$TL,groups_GOM)) %>% rename(vertex.names=groups_GOM,TL=V1)
TL<-TL %>% mutate(TL = as.numeric(TL)) %>% mutate(TL = round(TL,2))
n_GOM<-left_join(n_GOM,TL,by="vertex.names")

#adjust Detritus storage so it doesn't swamp everything
det_MAB<-max(MAB.rpath$Biomass)
det_GB<-max(GB.bal$Biomass)
det_GOM<-max(GOM$Biomass)
n_MAB<-n_MAB %>% mutate(storage_adjust = ifelse(storage == det_MAB,100,storage))
n_MAB <- n_MAB %>% mutate(storage_adjust = ifelse(storage < 0.05,0.05,storage_adjust))
n_GB<-n_GB %>% mutate(storage_adjust = ifelse(storage == det_GB,100,storage))
n_GB <- n_GB %>% mutate(storage_adjust = ifelse(storage < 0.05,0.05,storage_adjust))
n_GOM <- n_GOM %>% mutate(storage_adjust = ifelse(storage < 0.05,0.05,storage))
n_GOM <- n_GOM %>% mutate(storage_adjust = ifelse(storage == det_GOM,100,storage))
#n_GOM <- n_GOM %>% mutate(flow = ifelse(flow<0.1,0,flow))

GOM_web<-ggplot(n_GOM,aes(x, y, xend = xend, yend = yend)) +
  geom_edges(arrow = arrow(length = unit(7, "pt"), type = "open"),
             curvature = 0.15,position="jitter",
             aes(color=TL,linewidth=flow)) +
  scale_color_gradientn(colors = turbo(6))+
  scale_linewidth(range = c(0.15,9))+
  geom_nodelabel(aes(label=vertex.names,size=((storage_adjust))),show.legend = F) +
  scale_size(range=c(3,10))+
  guides(linewidth="none")+
  annotate("text",x=0.025,y=0.975,label="GOM",size=9)+
  theme_blank(legend.position="none")+
  theme_blank(legend.position=c(0.8,0.2))+
  theme(panel.background = element_rect(fill="#EEEEEEFF"),
        plot.background = element_rect(fill="#EEEEEEFF"),
        legend.background=element_rect(fill="#EEEEEEFF"))

GOM_web
#save
#ggsave(filename = "GOM_web.png",GOM_web,width=13.65,height = 10.8,dpi = 300)

GB_web<-ggplot(n_GB,aes(x, y, xend = xend, yend = yend)) +
  geom_edges(arrow = arrow(length = unit(7, "pt"), type = "open"),
             curvature = 0.1,position="jitter",
             aes(color=TL,linewidth=flow)) +
  scale_color_gradientn(colors = turbo(6))+
  scale_linewidth(range = c(0.15,10))+
  geom_nodelabel(aes(label=vertex.names,size=((storage_adjust))),show.legend = F) +
  scale_size(range=c(3,10))+
  guides(linewidth="none")+
  annotate("text",x=0.025,y=0.975,label="GB",size=9)+
  theme_blank(legend.position="none")+
  theme_blank(legend.position=c(0.8,0.2))+
  theme(panel.background = element_rect(fill="#EEEEEEFF"),
        plot.background = element_rect(fill="#EEEEEEFF"),
        legend.background=element_rect(fill="#EEEEEEFF"))

GB_web
#save
ggsave(filename = "GB_web.png",GB_web,width=15,height = 10.8,dpi = 300)

MAB_web<-ggplot(n_MAB,aes(x, y, xend = xend, yend = yend)) +
  geom_edges(arrow = arrow(length = unit(7, "pt"), type = "open"),
             curvature = 0.11,position="jitter",
             aes(color=TL,linewidth=flow)) +
  #scale_color_viridis(option = "turbo")+
  scale_color_gradientn(colors = turbo(6))+
  scale_linewidth(range = c(0.15,9))+
  geom_nodelabel(aes(label=vertex.names,size=((storage_adjust))),show.legend = F) +
  scale_size(range=c(3,10))+
  guides(linewidth="none")+
  annotate("text",x=0.025,y=0.975,label="MAB",size=9)+
  theme_blank(legend.position=c(0.9,0.15))+
  theme(panel.background = element_rect(fill="#EEEEEEFF"),
        plot.background = element_rect(fill="#EEEEEEFF"),
        legend.background=element_rect(fill="#EEEEEEFF"))

MAB_web
#save
ggsave(filename = "MAB_web.png",MAB_web,width=13.65,height = 10.8,dpi = 300)

Figure_2<-GOM_web+MAB_web +plot_layout(guides="collect")
Figure_2

```



##5.3 Figure 3: A/C plots

```{r}
#set color palette
my.pal1<-brewer.pal(8,"Set2")
my.pal2<-brewer.pal(12,"Paired")

Figure_3a<-ASC_CAP_GOM %>%
  mutate(condition = fct_relevel(condition,"initial","constrained")) %>%
  ggplot(aes(x=ASC_CAP, fill=condition))+
  geom_density(alpha=0.4)+
  geom_vline(xintercept=info_orig_GOM$ASC.CAP,color=my.pal2[10],linetype="dashed",linewidth=1)+
  geom_vline(xintercept = 0.4,color="black",linetype="dashed",linewidth=1)+
  scale_fill_manual(values = c(my.pal2[9],my.pal2[10]))+
  labs(x="A/DC",y="density",title = "GOM")+
  coord_cartesian(xlim = c(0.275,0.505), ylim = c(0,15),expand = F)+
  geom_text(y=14,x=0.375,label="****")+
  theme_Publication()+
  theme(plot.title = element_text(size=18),legend.position = "inside",legend.position.inside = c(0.9,0.825))

Figure_3b<-ASC_CAP_GB %>%
  mutate(condition = fct_relevel(condition,"initial","constrained"))%>%
  ggplot(aes(x=ASC_CAP,fill=condition))+
  geom_density(alpha=0.5)+
  geom_vline(xintercept=info_orig_GB$ASC.CAP,color=my.pal2[8],linetype="dashed",linewidth=1)+
  geom_vline(xintercept = 0.4,color="black",linetype="dashed",linewidth=1)+
  scale_fill_manual(values = c(my.pal2[7],my.pal2[8]))+
  labs(x="A/DC",y="density",title="GB")+
  coord_cartesian(xlim = c(0.275,0.505), ylim = c(0,14),expand = F)+
  geom_text(y=12.5,x=0.36,label="****")+
  theme_Publication()+
  theme(plot.title = element_text(size=18),legend.position = "inside",legend.position.inside = c(0.9,0.9))

Figure_3c<-ASC_CAP_MAB %>%
  mutate(condition = fct_relevel(condition,"initial","constrained")) %>%
  ggplot(aes(x=ASC_CAP,fill=condition))+
  geom_density(alpha=0.5)+
  geom_vline(xintercept=info_orig_MAB$ASC.CAP,color=my.pal2[6],linetype="dashed",linewidth=1)+
  geom_vline(xintercept = 0.4,color="black",linetype="dashed",linewidth=1)+
  scale_fill_manual(values = c(my.pal2[5],my.pal2[6]))+
  labs(x="A/DC",y="density",title ="MAB")+
  coord_cartesian(xlim = c(0.275,0.505), ylim = c(0,15),expand = F)+
  geom_text(y=14.5,x=0.39,label="****")+
  theme_Publication()+
  theme(plot.title = element_text(size=18),legend.position = "inside",legend.position.inside = c(0.9,0.825))
Figure_3c

Figure_3<-Figure_3a/Figure_3b/Figure_3c
Figure_3<-Figure_3+plot_annotation(tag_levels = "A")
Figure_3
```
##5.4 Figure 4: Flow metric comparisons (constrained to initial)
```{r}
games_test <- ASC_CAP %>% filter(condition == "constrained") %>% games_howell_test(ASC_CAP ~ EPU, detailed = T)

Figure_4b<-ASC_CAP %>% filter(condition == "constrained") %>%
  ggplot(aes(y=ASC_CAP,x=EPU,color=EPU))+
  geom_hline(yintercept = 0.4,color="black",linetype="dashed",linewidth=1)+
  geom_quasirandom(size = 1, width = .2, alpha = .25)+
  stat_summary(fun = mean, geom = "point", shape =95,size = 24) + 
  scale_color_manual(values=c(my.pal2[8],my.pal2[6],my.pal2[10]))+
  theme_Publication()+
  stat_pvalue_manual(games_test,label = "p.adj.signif",y.position = 0.5,step.increase = 0.05)+
  labs(y="Relative Ascendency",x="",title = "Constrained Condition")+
  theme(legend.position = "none",text = element_text(size=12))

games_test <- ASC_CAP %>% filter(condition == "initial") %>% games_howell_test(ASC_CAP ~ EPU, detailed = T)

Figure_4a<-ASC_CAP %>% filter(condition == "initial") %>%
  ggplot(aes(y=ASC_CAP,x=EPU,color=EPU))+
  geom_hline(yintercept = 0.4,color="black",linetype="dashed",linewidth=1)+
  geom_quasirandom(size = 1, width = .2, alpha = .25)+
  stat_summary(fun = mean, geom = "point", shape = 95,size = 24) + 
  scale_color_manual(values=c(my.pal2[7],my.pal2[5],my.pal2[9]))+
  theme_Publication()+
  stat_pvalue_manual(games_test,label = "p.adj.signif",y.position = 0.5,step.increase = 0.05)+
  labs(y="Relative Ascendency",x="",title="Initial Condition")+
  theme(legend.position = "none",text = element_text(size=12))

Figure_4<-Figure_4a+Figure_4b
Figure_4<-Figure_4+plot_annotation(tag_levels = "A")
Figure_4
```
##5.5 Figure 5: Group-level flow distributions
```{r}
flow %>%
  filter(EPU == "GOM")%>%
  filter(condition == "initial") %>%
  ggplot(aes(x=flow))+
  geom_density(alpha = 0.4, fill= my.pal2[6])+
  theme_Publication()+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  theme(legend.position = "none",axis.text.y = element_blank(),axis.ticks.y=element_blank())+
  facet_wrap(vars(group),nrow=6,scales="free")
```

##5.6 Figures 6 and 7: Flow metric comparisons (constrained to initial)

```{r}
flow<-left_join(flow,ks_flow,by=c("group","EPU"))
#make new column for unique EPU+condition variable
flow <- flow %>% mutate(EPU_condition = paste(EPU,condition,sep = " ")) %>%
    mutate(EPU_condition = fct_relevel(EPU_condition,"GOM initial","GOM constrained","GB initial","GB constrained","MAB initial","MAB constrained")) %>% add_significance("p")
  
  
Figure_6a<-flow %>%
  filter(group == "Phytoplankton") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.5,linewidth=0.5)+
  facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
  #scale_fill_manual(values = c(my.pal2[4],my.pal2[2],my.pal2[12],my.pal2[10],my.pal2[8],my.pal2[6]))+
  scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
  ggtitle(label = "Phytoplankton")+
  theme_Publication()+
  theme(legend.position = "none")+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  theme(text = element_text(size=12),axis.text.y = element_blank(),axis.ticks.y=element_blank())

Figure_6b<-flow %>%
  filter(group == "SmCopepods") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.5,linewidth=0.5)+
  facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
  #scale_fill_manual(values = c(my.pal2[4],my.pal2[2],my.pal2[12],my.pal2[10],my.pal2[8],my.pal2[6]))+
  scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
  ggtitle(label = "SmCopepods")+
  theme_Publication()+
  theme(legend.position = "none")+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05)))+
  theme(text = element_text(size=12),axis.text.y = element_blank(),axis.ticks.y=element_blank())

Figure_6c<-flow %>%
  filter(group == "SmPelagics") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.5,linewidth=0.5)+
  facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
  #scale_fill_manual(values = c(my.pal2[4],my.pal2[2],my.pal2[12],my.pal2[10],my.pal2[8],my.pal2[6]))+
  scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
  ggtitle(label = "SmPelagics")+
  theme_Publication()+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05)))+
  theme(text = element_text(size=12),legend.position = "bottom",axis.text.y = element_blank(),axis.ticks.y=element_blank())

Figure_7a<-flow %>%
  filter(group == "LgCopepods") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.5,linewidth=0.5)+
  facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
  scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
  ggtitle(label = "LgCopepods")+
  theme_Publication()+
  theme(legend.position = "none")+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  theme(text = element_text(size=12),axis.text.y = element_blank(),axis.ticks.y=element_blank())

Figure_7b<-flow %>%
  filter(group == "Macrobenthos") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.5,linewidth=0.5)+
  facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
  scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
  ggtitle(label = "Macrobenthos")+
  theme_Publication()+
  theme(legend.position = "none")+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  theme(text = element_text(size=12),axis.text.y = element_blank(),axis.ticks.y=element_blank())

Figure_7c<-flow %>%
  filter(group == "Megabenthos") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.5,linewidth=0.5)+
  facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
  scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
  ggtitle(label = "Megabenthos")+
  theme_Publication()+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  theme(text = element_text(size=12),axis.text.y = element_blank(),axis.ticks.y=element_blank(),legend.position = "bottom")

# Figure_6g<-flow %>%
#   filter(group == "Detritus") %>%
#   ggplot(aes(x=flow,fill=condition))+
#   geom_density(alpha = 0.5,linewidth=0.5)+
#   facet_wrap(~fct_relevel(EPU,"GOM","GB","MAB"),scales = "free")+
#   scale_fill_manual(values = c(my.pal2[11],my.pal2[1]))+
#   ggtitle(label = "Detritus")+
#   theme_Publication()+
#   theme(legend.position = "bottom")+
#   coord_cartesian(expand = F)+
#   theme(text = element_text(size=12))


Figure_6<-Figure_6a/Figure_6b/Figure_6c
Figure_6<-Figure_6+plot_annotation(tag_levels = "A")
Figure_6
Figure_7<-Figure_7a/Figure_7b/Figure_7c
Figure_7<-Figure_7+plot_annotation(tag_levels = "A")
Figure_7
```
#6 Supplemental Figures and Tables
#6.3 Balanced model parameters for each model
```{r}
#GOM 
GOM_print<-as.data.frame(matrix(ncol=9,nrow=(nliving_GOM+ndead_GOM)))
colnames(GOM_print)<-c("Group","TL","B","PB","QB","BA","Catch","Unassim","EE")
GOM_print$Group<-GOM$Group[1:(nliving_GOM+ndead_GOM)]
GOM_print$TL<-GOM$TL[1:(nliving_GOM+ndead_GOM)]
GOM_print$B<-GOM$Biomass[1:(nliving_GOM+ndead_GOM)]
GOM_print$PB<-GOM$PB[1:(nliving_GOM+ndead_GOM)]
GOM_print$QB<-GOM$QB[1:(nliving_GOM+ndead_GOM)]
GOM_print$BA<-GOM$BA[1:(nliving_GOM+ndead_GOM)]
GOM_print$Catch<-rowSums(GOM$Landings)[1:(nliving_GOM+ndead_GOM)]
GOM_print$Unassim<-GOM$Unassim[1:(nliving_GOM+ndead_GOM)]
GOM_print$EE<-GOM$EE[1:(nliving_GOM+ndead_GOM)]
write.csv(GOM_print,"GOM_balanced.csv")

#GOM diet
GOM_DC<-GOM$DC
GOM_prey<-c(groups_GOM[1:(nliving_GOM+ndead_GOM)],"Import")
GOM_diet<-c()
for (i in 1:(nliving_GOM)){
  group<-groups_GOM[i]
  diet<-cbind(rep(group,(nliving_GOM+ndead_GOM+1)),GOM_prey, GOM_DC[,i])
  GOM_diet<-rbind(GOM_diet,diet)
}
GOM_diet<-as.data.frame(GOM_diet)
colnames(GOM_diet) <- c("pred","prey","prop")
GOM_diet<-GOM_diet %>% filter(!prop==0)
GOM_diet <- GOM_diet %>% mutate(prop = as.numeric(prop)) %>%
  mutate(prop = prop*100)

write.csv(GOM_diet,"GOM_diet.csv")

#GOM pedigree
GOM_pedigree<-as.data.frame(GOM.params$pedigree)[,1:5]
write.csv(GB_pedigree,"GOM_pedigree.csv")

#GB model
GB_print<-as.data.frame(matrix(ncol=9,nrow=(nliving_GB+ndead_GB)))
colnames(GB_print)<-c("Group","TL","B","PB","QB","BA","Catch","Unassim","EE")
GB_print$Group<-GB.bal$Group[1:(nliving_GB+ndead_GB)]
GB_print$TL<-GB.bal$TL[1:(nliving_GB+ndead_GB)]
GB_print$B<-GB.bal$Biomass[1:(nliving_GB+ndead_GB)]
GB_print$PB<-GB.bal$PB[1:(nliving_GB+ndead_GB)]
GB_print$QB<-GB.bal$QB[1:(nliving_GB+ndead_GB)]
GB_print$BA<-GB.bal$BA[1:(nliving_GB+ndead_GB)]
GB_print$Catch<-rowSums(GB.bal$Landings)[1:(nliving_GB+ndead_GB)]
GB_print$Unassim<-GB.bal$Unassim[1:(nliving_GB+ndead_GB)]
GB_print$EE<-GB.bal$EE[1:(nliving_GB+ndead_GB)]
write.csv(GB_print,"GB_balanced.csv")

#GB diet
GB_DC<-GB.bal$DC
GB_prey<-c(groups_GB[1:(nliving_GB+ndead_GB)],"Import")
GB_diet<-c()
for (i in 1:(nliving_GB)){
  group<-groups_GB[i]
  diet<-cbind(rep(group,(nliving_GB+ndead_GB+1)),GB_prey, GB_DC[,i])
  GB_diet<-rbind(GB_diet,diet)
}
GB_diet<-as.data.frame(GB_diet)
colnames(GB_diet) <- c("pred","prey","prop")
GB_diet<-GB_diet %>% filter(!prop==0)
GB_diet <- GB_diet %>% mutate(prop = as.numeric(prop)) %>%
  mutate(prop = prop*100)

write.csv(GB_diet,"GB_diet.csv")

#GB pedigree
GB_pedigree<-as.data.frame(GB.params.bal$pedigree)[,1:5]
write.csv(GB_pedigree,"GB_pedigree.csv")

#MAB model
MAB_print<-as.data.frame(matrix(ncol=9,nrow=(nliving_MAB+ndead_MAB)))
colnames(MAB_print)<-c("Group","TL","B","PB","QB","BA","Catch","Unassim","EE")
MAB_print$Group<-MAB.rpath$Group[1:(nliving_MAB+ndead_MAB)]
MAB_print$TL<-MAB.rpath$TL[1:(nliving_MAB+ndead_MAB)]
MAB_print$B<-MAB.rpath$Biomass[1:(nliving_MAB+ndead_MAB)]
MAB_print$PB<-MAB.rpath$PB[1:(nliving_MAB+ndead_MAB)]
MAB_print$QB<-MAB.rpath$QB[1:(nliving_MAB+ndead_MAB)]
MAB_print$BA<-MAB.rpath$BA[1:(nliving_MAB+ndead_MAB)]
MAB_print$Catch<-rowSums(MAB.rpath$Landings)[1:(nliving_MAB+ndead_MAB)]
MAB_print$Unassim<-MAB.rpath$Unassim[1:(nliving_MAB+ndead_MAB)]
MAB_print$EE<-MAB.rpath$EE[1:(nliving_MAB+ndead_MAB)]
write.csv(MAB_print,"MAB_balanced.csv")

#MAB diet
MAB_DC<-MAB.rpath$DC
MAB_prey<-c(groups_MAB[1:(nliving_MAB+ndead_MAB)],"Import")
MAB_diet<-c()
for (i in 1:(nliving_MAB)){
  group<-groups_MAB[i]
  diet<-cbind(rep(group,(nliving_MAB+ndead_MAB+1)),MAB_prey, MAB_DC[,i])
  MAB_diet<-rbind(MAB_diet,diet)
}
MAB_diet<-as.data.frame(MAB_diet)
colnames(MAB_diet) <- c("pred","prey","prop")
MAB_diet<-MAB_diet %>% filter(!prop==0)
MAB_diet <- MAB_diet %>% mutate(prop = as.numeric(prop)) %>%
  mutate(prop = prop*100)

write.csv(MAB_diet,"MAB_diet.csv")

#MAB pedigree
MAB_pedigree<-as.data.frame(MAB.rpath.params$pedigree)[,1:5]
write.csv(MAB_pedigree,"MAB_pedigree.csv")
```
#6.3 Supplemental figures: flow distributions for all models, all groups
```{r}
flow<-flow %>% mutate(p.signif = ifelse(p.signif=="ns","",p.signif))
Figure_S1<- flow %>%
  filter(EPU == "GOM") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.4)+
  scale_fill_manual(values = c(my.pal2[9],my.pal2[10]))+
  theme_Publication()+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  labs(title = "GOM")+
  theme(legend.position = "bottom",axis.text.y = element_blank(),axis.ticks.y=element_blank())+
  facet_wrap(vars(group),nrow=6,scales="free")
Figure_S1

Figure_S2<- flow %>%
  filter(EPU == "GB") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.4)+
  scale_fill_manual(values = c(my.pal2[7],my.pal2[8]))+
  theme_Publication()+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  labs(title = "GB")+
  theme(legend.position = "bottom",axis.text.y = element_blank(),axis.ticks.y=element_blank())+
  facet_wrap(vars(group),nrow=6,scales="free")
Figure_S2

Figure_S3<- flow %>%
  filter(EPU == "MAB") %>%
  ggplot(aes(x=flow,fill=condition))+
  geom_density(alpha = 0.4)+
  scale_fill_manual(values = c(my.pal2[5],my.pal2[6]))+
  theme_Publication()+
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))+
  geom_text_npc(aes(label = p.signif),npcy=0.98,npcx=0.02)+
  labs(title = "MAB")+
  theme(legend.position = "bottom",axis.text.y = element_blank(),axis.ticks.y=element_blank())+
  facet_wrap(vars(group),nrow=6,scales="free")
Figure_S3

```


